"""JSON validation for AST structures.

This module provides validation for JSON AST representations
generated by the LLM.
"""

from __future__ import annotations

from typing import Any

from src.core.entities.behavioral_model import NodeType


class ASTJSONValidator:
    """Validator for AST JSON structures.

    Validates that the JSON output from the LLM conforms to the
    expected AST schema.
    """

    # Required fields for root node
    REQUIRED_ROOT_FIELDS = {"type"}

    # Valid node types
    VALID_NODE_TYPES = {nt.value for nt in NodeType}

    def __init__(self, strict: bool = False) -> None:
        """Initialize the validator.

        Args:
            strict: If True, enforce stricter validation rules
        """
        self.strict = strict

    def validate(self, ast_json: dict[str, Any]) -> tuple[bool, list[str]]:
        """Validate an AST JSON structure.

        Args:
            ast_json: The AST JSON to validate

        Returns:
            Tuple of (is_valid, list of error messages)
        """
        errors: list[str] = []

        if not isinstance(ast_json, dict):
            return False, ["AST must be a JSON object"]

        # Validate root node
        self._validate_node(ast_json, errors, path="root")

        return len(errors) == 0, errors

    def _validate_node(
        self,
        node: dict[str, Any],
        errors: list[str],
        path: str,
    ) -> None:
        """Recursively validate an AST node.

        Args:
            node: The node to validate
            errors: List to accumulate errors
            path: Path to the current node for error messages
        """
        # Check required fields
        if "type" not in node:
            errors.append(f"{path}: Missing required field 'type'")
            return

        # Validate node type
        node_type = node.get("type")
        if node_type not in self.VALID_NODE_TYPES:
            if self.strict:
                errors.append(f"{path}: Invalid node type '{node_type}'")
            # In non-strict mode, we accept unknown types

        # Validate children if present
        children = node.get("children", [])
        if not isinstance(children, list):
            errors.append(f"{path}: 'children' must be an array")
        else:
            for i, child in enumerate(children):
                if not isinstance(child, dict):
                    errors.append(f"{path}.children[{i}]: Must be an object")
                else:
                    self._validate_node(child, errors, f"{path}.children[{i}]")

        # Validate line number if present
        line = node.get("line")
        if line is not None and not isinstance(line, int):
            errors.append(f"{path}: 'line' must be an integer")

        # Validate metadata if present
        metadata = node.get("metadata")
        if metadata is not None and not isinstance(metadata, dict):
            errors.append(f"{path}: 'metadata' must be an object")

    def validate_structure_completeness(
        self,
        ast_json: dict[str, Any],
    ) -> tuple[bool, list[str]]:
        """Validate that the AST has meaningful structure.

        Args:
            ast_json: The AST JSON to validate

        Returns:
            Tuple of (is_valid, list of warnings)
        """
        warnings: list[str] = []

        # Check for empty body
        children = ast_json.get("children", [])
        if not children:
            warnings.append("AST has no children - may be empty or trivial")

        # Check for at least some meaningful content
        node_types = self._collect_node_types(ast_json)

        meaningful_types = {
            "function",
            "class",
            "assignment",
            "import",
            "if",
            "for",
            "while",
        }

        if not node_types & meaningful_types:
            warnings.append("AST contains no meaningful structural nodes")

        return len(warnings) == 0, warnings

    def _collect_node_types(self, node: dict[str, Any]) -> set[str]:
        """Recursively collect all node types in the AST.

        Args:
            node: The root node

        Returns:
            Set of node type strings
        """
        types: set[str] = set()

        if "type" in node:
            types.add(node["type"])

        for child in node.get("children", []):
            if isinstance(child, dict):
                types.update(self._collect_node_types(child))

        return types

    def extract_statistics(self, ast_json: dict[str, Any]) -> dict[str, int]:
        """Extract statistics about the AST.

        Args:
            ast_json: The AST JSON

        Returns:
            Dictionary of statistics
        """
        stats: dict[str, int] = {
            "total_nodes": 0,
            "functions": 0,
            "classes": 0,
            "assignments": 0,
            "imports": 0,
            "control_flow": 0,
            "max_depth": 0,
        }

        self._collect_statistics(ast_json, stats, depth=0)
        return stats

    def _collect_statistics(
        self,
        node: dict[str, Any],
        stats: dict[str, int],
        depth: int,
    ) -> None:
        """Recursively collect statistics from the AST.

        Args:
            node: The current node
            stats: Statistics dictionary to update
            depth: Current depth in the tree
        """
        stats["total_nodes"] += 1
        stats["max_depth"] = max(stats["max_depth"], depth)

        node_type = node.get("type", "")

        if node_type == "function":
            stats["functions"] += 1
        elif node_type == "class":
            stats["classes"] += 1
        elif node_type == "assignment":
            stats["assignments"] += 1
        elif node_type == "import":
            stats["imports"] += 1
        elif node_type in ("if", "for", "while", "try"):
            stats["control_flow"] += 1

        for child in node.get("children", []):
            if isinstance(child, dict):
                self._collect_statistics(child, stats, depth + 1)
